///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 19.11.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp1252).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#    include <HALCON/HpThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#    include <HALCONxl/HpThread.h>
#  endif
#  include <stdio.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;

// Procedure declarations 
// Local procedures 
void Crown_Get_Circle (HObject ho_ImageRaw, HObject *ho_ROIDisp, HObject *ho_CrownContourDisp, 
    HTuple hv_cfROICenterY, HTuple hv_cfROICenterX, HTuple hv_cfROICenterRad, HTuple hv_cfBackgroundColor, 
    HTuple hv_cfCrownSelectFilter, HTuple hv_cfDefectSizeAllowed, HTuple *hv_Row, 
    HTuple *hv_Column, HTuple *hv_Radius);

// Procedures 
// Local procedures 
void Crown_Get_Circle (HObject ho_ImageRaw, HObject *ho_ROIDisp, HObject *ho_CrownContourDisp, 
    HTuple hv_cfROICenterY, HTuple hv_cfROICenterX, HTuple hv_cfROICenterRad, HTuple hv_cfBackgroundColor, 
    HTuple hv_cfCrownSelectFilter, HTuple hv_cfDefectSizeAllowed, HTuple *hv_Row, 
    HTuple *hv_Column, HTuple *hv_Radius)
{

  // Local iconic variables
  HObject  ho_ROI, ho_ImageReduced, ho_RegionDilation1;
  HObject  ho_RegionBin, ho_RegionClosing, ho_RegionFillUp;
  HObject  ho_ConnectedRegions, ho_SelectedRegions, ho_RegionCap;
  HObject  ho_RegionErosion, ho_RegionDilation, ho_Circle;
  HObject  ho_RegionDilation2;

  // Local control variables
  HTuple  hv_graphicBold, hv_Exception, hv_UsedThreshold;
  HTuple  hv_closingFilter, hv_Value1, hv_Value;

  //** find crown circle, then check flare
  hv_graphicBold = 3.5;

  try
  {
    //ROI
    GenCircle(&ho_ROI, hv_cfROICenterY, hv_cfROICenterX, hv_cfROICenterRad);
    ReduceDomain(ho_ImageRaw, ho_ROI, &ho_ImageReduced);

    //** ROI Overlay
    DilationCircle(ho_ROI, &ho_RegionDilation1, hv_graphicBold);
    Difference(ho_RegionDilation1, ho_ROI, &(*ho_ROIDisp));

  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    GenEmptyRegion(&(*ho_ROIDisp));
    //Can't create ROI
  }

  try
  {
    //pick up the brightest image channel
    if (0 != (int(hv_cfBackgroundColor>0)))
    {
      AccessChannel(ho_ImageReduced, &ho_ImageReduced, hv_cfBackgroundColor);
    }
    //find the dark part (bottle wall, fill level etc.)
    BinaryThreshold(ho_ImageReduced, &ho_RegionBin, "max_separability", "light", 
        &hv_UsedThreshold);

    hv_closingFilter = 9;
    ClosingCircle(ho_RegionBin, &ho_RegionClosing, hv_closingFilter);
    FillUp(ho_RegionClosing, &ho_RegionFillUp);

    //select the largest region
    Connection(ho_RegionFillUp, &ho_ConnectedRegions);
    RegionFeatures(ho_ConnectedRegions, "area", &hv_Value1);
    SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", hv_cfCrownSelectFilter, 
        999999);
    Union1(ho_SelectedRegions, &ho_RegionCap);
    RegionFeatures(ho_RegionCap, "rb", &hv_Value);
    if (0 != (int(hv_cfDefectSizeAllowed>(hv_Value-30))))
    {
      hv_cfDefectSizeAllowed = hv_Value-30;
    }

    ErosionCircle(ho_RegionCap, &ho_RegionErosion, hv_cfDefectSizeAllowed);
    DilationCircle(ho_RegionErosion, &ho_RegionDilation, hv_cfDefectSizeAllowed);

    //find crown circle
    SmallestCircle(ho_RegionDilation, &(*hv_Row), &(*hv_Column), &(*hv_Radius));
    GenCircle(&ho_Circle, (*hv_Row), (*hv_Column), (*hv_Radius));

    //** Crown contour Overlay
    DilationCircle(ho_Circle, &ho_RegionDilation2, hv_graphicBold);
    Difference(ho_RegionDilation2, ho_Circle, &(*ho_CrownContourDisp));

  }
  // catch (Exception) 
  catch (HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    GenEmptyRegion(&(*ho_CrownContourDisp));
  }

  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Image, ho_ImageRaw, ho_Rectangle;
  HObject  ho_ImageReduced, ho_ROIDisp, ho_CrownDisp, ho_ImagePart;
  HObject  ho_ImageZoom;

  // Local control variables
  HTuple  hv_dirPath, hv_AcqHandle, hv_ImageFiles;
  HTuple  hv_WindowID, hv_Index, hv_fileNameArr, hv_folderName;
  HTuple  hv_stringLength, hv_Substring, hv_Number, hv_Substring1;
  HTuple  hv_Camstring, hv_Exception, hv_cfBackgroundColor;
  HTuple  hv_cfROICenterX, hv_cfROICenterY, hv_cfROICenterRad;
  HTuple  hv_cfFlareHeight, hv_cfCrownSelectFilter, hv_cfDefectLengthAllowed;
  HTuple  hv_cfMinDefectCared, hv_fltGryMin, hv_fltGryMax;
  HTuple  hv_hueMin, hv_hueMax, hv_begin, hv_Row, hv_Column;
  HTuple  hv_Radius, hv_saveEnable, hv_borderWidth, hv_Width;
  HTuple  hv_Height, hv_end;

  //top view floater defects insp

  //read image from folder
  //dirPath := '202033/good'
  //dirPath := '202033/date'
  //dirPath := '202033/bright'
  //dirPath := '202033/flare'
  //dirPath := '202033/foreign'
  //dirPath := '202033/scratch'

  hv_dirPath = "CroppedImagesAug/good";
  hv_dirPath = "CroppedImagesAug/date";
  hv_dirPath = "CroppedImagesAug/bright";
  hv_dirPath = "CroppedImagesAug/flare";
  hv_dirPath = "CroppedImagesAug/foreign";
  hv_dirPath = "CroppedImagesAug/scratch";

  OpenFramegrabber("File", 1, 1, 0, 0, 0, 0, "default", -1, "default", -1, "default", 
      hv_dirPath, "default", -1, -1, &hv_AcqHandle);

  ListFiles(hv_dirPath, ((HTuple("files").Append("recursive")).Append("follow_links")), 
      &hv_ImageFiles);
  TupleRegexpSelect(hv_ImageFiles, (HTuple("\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima|hobj)$").Append("ignore_case")), 
      &hv_ImageFiles);

  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  SetWindowAttr("background_color","black");
  OpenWindow(0,0,960,600,0,"visible","",&hv_WindowID);
  HDevWindowStack::Push(hv_WindowID);


  //shuffle the images and seperate the images to training set and test set
  for (hv_Index=0; hv_Index<=499; hv_Index+=1)
  {
    //grab image
    GrabImage(&ho_Image, hv_AcqHandle);

    TupleSplit(HTuple(hv_ImageFiles[hv_Index]), "\\", &hv_fileNameArr);
    hv_folderName = ((const HTuple&)hv_fileNameArr)[1];
    TupleStrlen(HTuple(hv_fileNameArr[(hv_fileNameArr.TupleLength())-1]), &hv_stringLength);
    TupleStrFirstN(HTuple(hv_fileNameArr[(hv_fileNameArr.TupleLength())-1]), hv_stringLength-5, 
        &hv_Substring);

    TupleNumber(hv_Substring, &hv_Number);

    if (0 != (int((hv_Number%5)==0)))
    {
      WriteImage(ho_Image, "jpeg", 0, (("datasetsAug/test_crown/"+hv_folderName)+"/")+hv_Index);
    }
    else
    {
      WriteImage(ho_Image, "jpeg", 0, (("datasetsAug/train_crown/"+hv_folderName)+"/")+hv_Index);
    }
  }

  // stop(...); only in hdevelop
  // stop(...); only in hdevelop

  //align crown and crop images
  {
  HTuple end_val49 = (hv_ImageFiles.TupleLength())-1;
  HTuple step_val49 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val49, step_val49); hv_Index += step_val49)
  {
    //grab image
    //grab_image (ImageRaw, AcqHandle)


    try
    {
      TupleSplit(HTuple(hv_ImageFiles[hv_Index]), "\\", &hv_fileNameArr);
      hv_folderName = ((const HTuple&)hv_fileNameArr)[1];
      TupleStrlen(HTuple(hv_fileNameArr[(hv_fileNameArr.TupleLength())-1]), &hv_stringLength);
      TupleStrFirstN(HTuple(hv_fileNameArr[(hv_fileNameArr.TupleLength())-1]), hv_stringLength-5, 
          &hv_Substring);
      TupleStrFirstN(hv_Substring, 20, &hv_Substring1);
      TupleStrLastN(hv_Substring1, 20, &hv_Camstring);
    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
    }

    if (0 != (int(hv_folderName==HTuple("good"))))
    {
      ReadImage(&ho_Image, hv_dirPath+"/1583256722694776_cam10_202033_09.33.39.949");
    }
    else if (0 != (int(hv_folderName==HTuple("date"))))
    {
      ReadImage(&ho_Image, hv_dirPath+"/1583260430063484_cam10_202033_10.35.08.485");
    }
    else if (0 != (int(hv_folderName==HTuple("bright"))))
    {
      ReadImage(&ho_Image, hv_dirPath+"/1583277991129427_cam10_202033_15.27.49.259");
    }
    else if (0 != (int(hv_folderName==HTuple("flare"))))
    {
      ReadImage(&ho_Image, hv_dirPath+"/1583254409252087_cam10_202033_08.54.47.793");
    }
    else if (0 != (int(hv_folderName==HTuple("foreign"))))
    {
      ReadImage(&ho_Image, hv_dirPath+"/1583269706585509_cam10_202033_13.09.44.829");
    }
    else if (0 != (int(hv_folderName==HTuple("scratch"))))
    {
      ReadImage(&ho_Image, hv_dirPath+"/1583258118634121_cam10_202033_09.56.37.099");
    }


    //rotate image
    RotateImage(ho_Image, &ho_ImageRaw, (360.0/(hv_ImageFiles.TupleLength()))*hv_Index, 
        "constant");



    //0-color, 1-Red, 2-Green, 3-Blue
    hv_cfBackgroundColor = 0;
    hv_cfROICenterX = 1000;
    hv_cfROICenterY = 600;
    hv_cfROICenterRad = 600;

    hv_cfFlareHeight = 80;
    hv_cfCrownSelectFilter = 92000;
    hv_cfDefectLengthAllowed = 310;
    hv_cfMinDefectCared = 7;

    hv_fltGryMin = 20;
    hv_fltGryMax = 80;

    hv_hueMin = 0;
    hv_hueMax = 25;

    //white color hue
    //gen_rectangle2 (Rectangle, 600, 900, 0, 100, 100)
    //reduce_domain (ImageRaw, Rectangle, ImageReduced)
    //decompose3 (ImageReduced, Image1, Image2, Image3)
    //trans_from_rgb (Image1, Image2, Image3, Hue, Sat, Int, 'hsv')

    CountSeconds(&hv_begin);

    Crown_Get_Circle(ho_ImageRaw, &ho_ROIDisp, &ho_CrownDisp, hv_cfROICenterY, hv_cfROICenterX, 
        hv_cfROICenterRad, hv_cfBackgroundColor, hv_cfCrownSelectFilter, hv_cfDefectLengthAllowed, 
        &hv_Row, &hv_Column, &hv_Radius);

    //crop crown images
    hv_saveEnable = 1;
    if (0 != (int(hv_saveEnable==1)))
    {
      hv_borderWidth = 50;
      GenRectangle2(&ho_Rectangle, hv_Row, hv_Column, 0, hv_Radius+hv_borderWidth, 
          hv_Radius+hv_borderWidth);
      ReduceDomain(ho_ImageRaw, ho_Rectangle, &ho_ImageReduced);
      CropDomain(ho_ImageReduced, &ho_ImagePart);
      GetImageSize(ho_ImagePart, &hv_Width, &hv_Height);
      //ZOOM IMAGE
      ZoomImageSize(ho_ImagePart, &ho_ImageZoom, 120, 120, "constant");
      WriteImage(ho_ImageZoom, "bmp", 0, (("CroppedImagesAug/"+hv_folderName)+"/")+hv_Index);
    }

    CountSeconds(&hv_end);

    if (HDevWindowStack::IsOpen())
      DispObj(ho_ImageRaw, HDevWindowStack::GetActive());
    try
    {
      if (HDevWindowStack::IsOpen())
        SetDraw(HDevWindowStack::GetActive(),"fill");
      SetColor(hv_WindowID, "blue");
      if (HDevWindowStack::IsOpen())
        DispObj(ho_ROIDisp, HDevWindowStack::GetActive());
      SetColor(hv_WindowID, "green");
      if (HDevWindowStack::IsOpen())
        DispObj(ho_CrownDisp, HDevWindowStack::GetActive());
      SetColor(hv_WindowID, "yellow");

    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
    }


    //display result
    set_display_font(hv_WindowID, 15, "mono", "true", "false");
    disp_message(hv_WindowID, "Run Time  : "+((hv_end-hv_begin)*1000), "window", 
        60, 2, "green", "false");

    //stop ()
  }
  }

  CloseFramegrabber(hv_AcqHandle);

}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple      gStartMutex;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  // Wait until the timer has fired to start processing.
  LockMutex(gStartMutex);
  UnlockMutex(gStartMutex);

  try
  {
    action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
  }

  // Tell the main thread to terminate itself.
  LockMutex(gStartMutex);
  gTerminate = TRUE;
  UnlockMutex(gStartMutex);
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);

  for (;;)
  {
    HBOOL terminate;

    CFRunLoopRun();

    LockMutex(gStartMutex);
    terminate = gTerminate;
    UnlockMutex(gStartMutex);

    if (terminate)
      break;
  }

  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  int ret = 0;

  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#endif

    // file was stored with local-8-bit encoding
    //   -> set the interface encoding accordingly
    SetHcppInterfaceStringEncodingIsUtf8(false);

    // Default settings used in HDevelop (can be omitted)
    SetSystem("width", 512);
    SetSystem("height", 512);

#ifndef __APPLE__
    action();
#else
    ret = apple_main(argc,argv);
#endif
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
    ret = 1;
  }
  return ret;
}

#endif


#endif


